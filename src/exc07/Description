                            Создание обобщенного метода.
    Можно объявить обобщенный метод, в кото­ром непосредственно используется один или несколько параметров типа.
Более того, можно объявить обобщенный метод, входящий в необобщенный класс.

Пример.
    В приведенной ниже программе объявляется необобщенный класс GenMethDemo, а в нем - статический обобщенный
метод isIn(). Этот метод определяет, является ли объект членом массива. Его можно применять к любому типу
объектов и массивов, при условии, что массив содержит объекты, совместимые с типом искомого объекта.
    Рассмотрим метод isIn() подробнее. Прежде всего обратите внимание на объявление этого метода в следующей
строке кода:

static <Т extends Comparable<T>, V extends Т> boolean is!n(T х, V[] у) {
}

    Параметр типа объявляется до типа, возвращаемого методом. Обратите так­ же внимание на то, что тип Т расширяет
обобщенный тип Comparable<T>, где Comparable - это интерфейс, объявляемый в пакете java.lang. В классе, реализующем
интерфейс Comparable, определяются объекты, которые могут быть упорядочены. Следовательно, указание интерфейса
Comparable в качестве верхней границы гарантирует, что метод isIn() вполне применим к объектам, которые можно
сравнивать. Интерфейс Comparable является обобщенным, а параметрего типа обозначает тип сравниваемых объектов.
Обратите далее внимание на то, что тип V ограничен сверху типом Т. Это означает, что тип V должен быть тем же типом,
что и Т, или же типом его подкласса. Такая взаимосвязь подразумевает, что метод isIn() может быть вызван только с
совместимыми аргументами. И наконец, об­ ратите внимание на то , что метод isIn() объявлен как статический, что
позволяет вызывать его независимо ни от какого объекта. Следует, однако, иметь в виду, что обобщенные методы могут
быть как статическими, так и нестатическими. Никаких ограничений на этот счет не существует.
    А теперь обратите внимание на то, что метод isIn() вызывается из метода main() с нормальным синтаксисом вызовов,
не требуя указывать аргументы типа. Дело в том, что типы аргументов различаются автоматически, а типы Т и V соответ-
ственно подстраиваются. Например, в первом вызове этого метода.

if(isIn(2, nums))

    первый аргумент относится к типу Integer (благодаря автоупаковке), поэто­му вместо типа Т подставляется тип
Integer. Второй аргумент также относится к типу Integer, который подставляется вместо типа V. Во втором вызове данного
метода оба аргумента относятся к типу String, который и подставляется вместо типов Т и V.
    Для вызовов большинства обобщенных методов, как правило, достаточно и выведения типов, но если требуется, то аргу-
менты типа можно указать явно. В качестве примера ниже показано, как должен выглядеть первый вызов метода isIn(), если
явно указаны оба аргумента типа.
    GenМethDemo.<Integer, Integer>isIn(2, nums)

    Очевидно, что явное указание аргументов типа в данном случае не дает никаких преимуществ. Более того, выведение
типов в отношении методов было усо­вершенствовано в версии JDК 8. Таким образом, указывать аргументы типа явным образом
требуется лишь в крайне редких случаях.