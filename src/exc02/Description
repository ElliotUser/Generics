                                Каким образом обобщения повышают типовую безопасность.
    Обобщения автоматически гарантируют типовую безопасность во всех операциях, где задействован обобщенный класс Gen.
В процессе его применения исключается потребность в явном приведении и ручной проверке типов в приклодном коде.

ПРИМЕР.
    Чтобы стали понятнее выгоды от обобщений, рассмотрим сначала следующий пример программы, в которой создает необоб-
щенный эквивалент класса Gen.
    В этой версии программы обращает на себя внимание ряд интересных моментов. Прежде всего, в классе NonGen все ссылки
на тин Т заменены ссылками тип Object. Это позволяет хранить в классе NonGen объекты любого типа, как и в обобщенном
классе Gen. Нo это не позволяет компилятору Java получить какие-нибудь подлинные сведения о типе данных, фактически
сохраняемых в объекте класса NonGen, что плохо по двум причинам. Во-первых, для извлечения сохраненных данных требуется
явное приведение типов. И во-вторых, многие ошибки несоответствия типов не могут быть обнаружены до времени выполнения.
    Обратите внимание на следующую строку кода:

int v = (Integer) iob.getOb();

    Метод getOb() возвращает тип Object, поэтому его можно привести к типу Integer, чтобы выполнить автораспаковку и со-
хранить значение в переменной v. Если убрать приведение типов, программа не скомпелируется. Если в её версии с обобще-
ниями приведение типов производится неявно, то в версии без обобщений приведение должно быть сделано явно. Это не только
неудобно, но и служит потенциальным источником ошибок.
    Теперь рассмотрим следующий фрагмент кода в конце данной программы:

iob = strOb;
v = (Integer) iob.getOb(); // Ошибка во время выполнения!

    Здесь переменной экземпляра iOb присваивается значение переменной экземпляра strOb. Но переменная экземпляра strOb
ссылается на объект, содержащий символьную строку, а не целое число. Такое присваивание синтаксически корректно, потому
что все ссылки типа NonGen одинаковы и любая ссылка типа NonGen может указывать на любой другой объект типа NonGen. Но
семантически эта операция присваивания неверна, что и отражено в следующей стороке кода. Здесь тип, возвращаемый  ме-
тодом getOb(), приводится к типу Integer, а затем делается попытка присвоить полученное значение переменной v. Дело в
том что переменная экземпляра iOb теперь ссылается на объект, хранящий данные типа String, а не Integer. Без обобщений
компилятор Java не в состоянии обнаружить эту ошибку. Вместо этого во время выполнения генерируется исключение при по-
пытке привести к типу String.
