                            Ограниченные метасимвольные аргументы.
    Метасимвольные аргументы могут быть ограничены почти таким же образом, как и параметры типов. Ограничивать
метасимвольный аргумент особенно важно при создании обобщенного типа, оперирующего иерархией классов.

Пример.
    Рассмотрим иерархию классов, инкапсулиирующих координаты.
    На вершине этой иерархии находится класс TwoD, инкапсулирующий двумер­ные координаты ХY. Его наследует класс
ThreeD, вводя третье измерение и образуя координаты XYZ. Класс ThreeD наследует от класса FourD, вводящего че-
твертое измерение (время) и порождая четырехмерные координаты.
    Ниже приведен обобщенный класс Coords, хранящий массив координат.

//Этот класс хранит массив координатных объектов
class Coords<T extends TwoD> {
    Т[] coords;

    Coords(T[] о) {
        coords = о;
    }
}

    Обратите внимание на то, что в классе Coords задается параметр типа, ограниченный классом TwoD. Это означает,
что любой массив, сохраняемый в объекте типа Coords, будет содержать объект класса TwoD или любого из его подклас-
сов.
    А теперь допустим, что требуется написать метод, выводящий координаты Х и Y каждого элемента массива coords в
объекте класса Coords. Это нетрудно сделать с помощью метасимвола, как показано ниже, поскольку все типы объектов
класса Coords имеют, как минимум, пару координат (Х и Y).

static void showXY(Coords<?> c){
    System.out.println("Координаты X Y: ");
    for(int = 0; i < c.coords.length; i++)
        System.out.println(c.coords[i].x + " " + c.coords[i].y);
    System.out.println();
}

    Класс Coords относится к ограниченному обобщенному типу, для которого ука­ зан класс TwoD в качестве верхней
границы, поэтому все объекты, которые можно использовать для создания объекта типа Coords , будут массивами класса
TwoD или наследуемых от него классов. Таким образом, метод showXY() может выводить содержимое любого объекта типа
Coords.
    Но что, если требуется создать метод, выводящий координаты Х, Y и Z объекта типа ThreeD или FourD? Дело в том,
что не все объекты типа Coords будут иметь три координаты, поскольку объект типа Coords<TwoD> будет иметь только
коор­ динаты Х и У. Как же тогда написать метод, который будет выводить координаты Х, Y и Z для объектов типа
Coords<ThreeD> и Coords<FourD>, и в то же время не допустить использование этого метода с объектами типа
Coords<TwoD>? Ответ заключается в использовании ограниченных метасимвальных аргументов.
    Ограниченный метасимвол задает верхнюю или нижнюю границу для аргумента­ типа. Это позволяет ограничить типы
объектов, которыми будет оперировать метод. Наиболее распространен метасимвол, который накладывает ограничение
сверху и создается с помощью оператора extends почти так же, как и ограничен­ный тип.
    Применяя ограниченные метасимволы, нетрудно создать метод, выводящий координаты Х, Y и Z для объекта типа Coords,
если эти три координаты действи­тельно имеются у этого объекта. Например, приведенный ниже метод showXYZ() выводит
координаты элементов, сохраняемых в объекте типа Coords, если эти элементы относятся к классу ThreeD (или к насле-
дуемым от него классам).

static void showXYZ (Coords<? extends ThreeD> с){
    System.out.println("X Y Z Coordinates:");
    for(int i=O; i < c.coords.length; i++)
        System.out.println(c.coords[i].x + " " +
                           c.coords[i].y + " " +
                           c.coords[i].z);
    System.out.println();
}

    Обратите внимание на то, что оператор extends введен в метасимвол при объявлении параметра с. Это означает,
что метасимвол ? может совпадать с любым типом, при условии, что он относится к классу ThreeD или наследуемому
от него классу. Таким образом, оператор extends накладывает ограничение сверху на совпадение с метасимволом ?.
Вследствие этого ограничения метод showXYZ() может быть вызван со ссылками на объекты типа Coords<ThreeD> или
Coords<FourD>, но не со ссылкой на объект типа Coords<TwoD>. Попытка вызвать метод showXYZ() со ссылкой на объект
типа Coords<TwoD> приведет к ошибке во время компиляции. Тем самым обеспечивается типовая безопасность.
    Обратите внимание на следующие закомментированные строки:

// showXYZ(tdlocs); // Ошибка, это не тип ТhreeD
// showAll(tdlocs); // Ошибка, это не тип FourD
    Объект tdlocs относится к типу Coords<TwoD>, и его нельзя использовать для вызова метода showXYZ() или
showAll(),поскольку этому препятствуют ограниченные метасимвольные аргументы в их объявлении. Чтобы убедиться в
этом, попробуйте убрать комментарии из приведенных выше строк кода и скомпилиро­вать данную программу. В итоге
вы получите ошибку компиляции из-за несоответствия типов.
    В общем, чтобы установить верхнюю границу для метасимвола, следует воспользоваться приведенной ниже формой
метасимвольного выражения:

<? extends суперкласс>

    Здесь суперкласс обозначает имя класса, который служит верхней границей. Не следует забывать, что это включа-
ющее выражение, а следовательно, класс, заданный в качестве верхней границы (т.е. суперкласс) , также находится в
пределах допустимых типов.
    Имеется также возможность указать нижнюю границу для метасимвольного ар­гумента, введя оператор super в его
объявление. Ниже приведена общая форма наложения ограничения на метасимвольный аргумент снизу.

< ? super подкласс>

    В данном случае допустимыми аргументами могут быть только те классы, которые являются суперклассами для ука-
занного подкласса . Это исключающее выражение, поскольку оно не включает в себя заданный подкласс.

